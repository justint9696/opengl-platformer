#include "level/editor.h"

#include "entity/table.h"
#include "game/input.h"
#include "util/aabb.h"
#include "util/log.h"

#include <assert.h>
#include <cglm/struct.h>

void editor_init(editor_t *self) {
    memset(self, 0, sizeof(editor_t));
}

static void editor_idle(editor_t *self, world_t *world) {
    entity_t mouse = (entity_t) { 0 };
    mouse.body.pos = screen_to_world(world, mouse_get_position());

    if (!world_is_on_screen(world, mouse.body.pos))
        return;

    collider_t arr[64];
    size_t n = world_get_colliders(world, &mouse, arr, 64);

    for (size_t i = 0; i < n; i++) {
        collider_t *tmp = &arr[i];
        if (aabb_intersect_2d(&tmp->box, mouse.body.pos)) {
            self->entity = tmp->data;
            self->offset
                = glms_vec2_sub(mouse.body.pos, self->entity->body.pos);
            break;
        }
    }

    if (self->entity && mouse_pressed(SDL_BUTTON_RIGHT)) {
        entity_destroy(self->entity, world);
        self->entity = NULL;
    }

    if (self->entity && mouse_held(SDL_BUTTON_LEFT, 0)) {
        self->state = ES_MOVE;
        log_debug("Editor in move mode.\n");
    }

    if (button_pressed(SDL_SCANCODE_A)) {
        self->state = ES_PLACE;
        log_debug("Editor in place mode.\n");
    }
}

static void editor_move(editor_t *self, world_t *world) {
    assert(self->entity);
    vec2s mouse = screen_to_world(world, mouse_get_position());

    if (mouse_held(SDL_BUTTON_LEFT, 0)) {
        self->entity->body.pos = glms_vec2_sub(mouse, self->offset);
    } else if (mouse_released(SDL_BUTTON_LEFT)) {
        log_debug("Editor in idle mode.\n");
        self->state = ES_IDLE;
        self->entity = NULL;
    }
}

static void editor_place(editor_t *self, world_t *world) {
    if (button_pressed(SDL_SCANCODE_E)) {
        log_debug("Editor in idle mode.\n");
        self->state = ES_IDLE;
        return;
    }
    if (mouse_pressed(SDL_BUTTON_LEFT)) {
        vec2s mouse = screen_to_world(world, mouse_get_position());
        vec2s dim = (vec2s) { .x = 50.f, .y = 50.f };
        vec2s pos = glms_vec2_sub(mouse, glms_vec2_scale(dim, 0.5f));
        self->offset = glms_vec2_sub(mouse, pos);

        create_fn_t fn = table_lookup(ET_PLATFORM);
        assert(fn);
        self->entity = fn(pos, dim, world);
        log_debug("Entity placed at (%.2f, %.2f)\n", pos.x, pos.y);
        self->state = ES_MOVE;
    }
}

void editor_sync(editor_t *self, world_t *world) {
    if (mouse_pressed(SDL_BUTTON_LEFT)) {
        // check if entity is under mouse
        // if so, move that entity
        // otherwise, place block
    } else if (mouse_pressed(SDL_BUTTON_RIGHT)) {
        // remove block
    }
}

/* void editor_sync(editor_t *self, world_t *world) { */
/*     switch (self->state) { */
/*         case ES_IDLE: */
/*             editor_idle(self, world); */
/*             break; */
/*         case ES_MOVE: */
/*             editor_move(self, world); */
/*             break; */
/*         case ES_PLACE: */
/*             editor_place(self, world); */
/*             break; */
/*         default: */
/*             break; */
/*     } */
/* } */
